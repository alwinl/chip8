/*
 * asm_emitter.cc Copyright 2026 Alwin Leerling dna.leerling@gmail.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include "asm_emitter.h"

#include "binary_loader.h"

#include <iomanip>

struct StreamStateGuard
{
    StreamStateGuard(std::ostream& os) : os(os), flags(os.flags()), fill(os.fill()) {}

    ~StreamStateGuard() {
        os.flags(flags);
        os.fill(fill);
    }

    std::ostream& os;
    std::ios::fmtflags flags;
    char fill;
};


void ASMEmitter::emit_label( std::ostream& os, const IRProgram& ir, uint16_t address )
{
	std::string label = ir.symbols.get_label( address );

	if( !label.empty() )
		label += ":";

	os << std::left << std::setw(8) << std::setfill(' ') << label;
}

void ASMEmitter::emit_address( std::ostream& os, uint16_t address )
{
	os << "0x" << std::hex << std::uppercase << std::setw(3) << std::setfill('0') << address << "  ";
}

void ASMEmitter::emit_opcode( std::ostream& os, const IRProgram& ir, const BinImage& bin_image, uint16_t address )
{
	uint8_t high_byte = bin_image[ address - ir.origin ];
	uint8_t low_byte  = bin_image[ address - ir.origin + 1 ];

	os << std::hex << std::uppercase
		<< std::setw(2) << std::setfill('0') << +high_byte << " ";

	os << std::hex << std::uppercase
		<< std::setw(2) << std::setfill('0') << +low_byte << "  ";
}

void ASMEmitter::emit_mnemonic( std::ostream& os, const Opcode& opcode )
{
	static std::array<std::string, opcode_count> mnemonics = {
		"NOP", "CLS", "RET", "JP", "CALL", "SE",
		"SNE", "LD", "ADD", "OR", "AND",
		"XOR", "SUB", "SHR", "SUBN", "SHL", "LD I,",
		"JP V0,", "RND", "DRW", "SKP", "SKNP", "LD DT,",
		"LD ST,", "ST K,", "ST DT,", "ADD I,",
		"LD F,", "LD B,", "ST [I],", "LD [I],"
	};

	os << mnemonics[ static_cast<int>(opcode) ];
}

void ASMEmitter::emit_operand( std::ostream& os, const IRProgram& ir, const Operand& op )
{
    std::visit( [&](auto&& v)
	{
		StreamStateGuard guard(os);

        using T = std::decay_t<decltype(v)>;

		if constexpr( std::is_same_v<T, Reg> )
			os << "V" << std::uppercase << std::hex << +v.index;

		else if constexpr( std::is_same_v<T, Addr> ) {
			std::string target = ir.symbols.get_label( v.value );
			if( target.empty() )
				os << "0x" << std::uppercase << std::hex << std::setw(3) << std::setfill('0') << +v.value;
			else
				os << target;
		}

		else if constexpr( std::is_same_v<T, Imm> )
			os << "#" << std::dec << +v.value;

		else if constexpr( std::is_same_v<T, Nibble> )
			os << "0x" << std::uppercase << std::hex << +v.value;

		else if constexpr( std::is_same_v<T, Key> )
			os << "K" << std::uppercase << std::hex << +v.index;

		else if constexpr( std::is_same_v<T, RegCount> )
			os << "V0-V" << std::uppercase << std::hex << +v.count;

    }, op);
}

void ASMEmitter::emit_element( std::ostream& os, const IRProgram& ir, const BinImage& bin_image, OutputMode mode, const InstructionElement& element )
{
	const Instruction& instruction = element.instruction;

	if( mode == OutputMode::Listing ) {
		emit_address( os, element.address );
		emit_opcode( os, ir, bin_image, element.address );
	}

	emit_label( os, ir, element.address );

	emit_mnemonic( os, instruction.opcode() );

	for( bool first = true; const auto& operand : instruction.operands() )
	{
		os << (first ? " " : ", " );
		first = false;

		emit_operand( os, ir, operand );
	}

	os << "\n";
}

void ASMEmitter::emit_element( std::ostream& os, const IRProgram& ir, const BinImage& bin_image, OutputMode mode, const DataElement& element )
{
	if( mode == OutputMode::Listing )
		emit_address( os, element.address );

	emit_label( os, ir, element.address );

	os << ".DB";

	for( bool first = true; const auto& byte : element.byte_run )
	{
		os << (first ? " " : ", " );
		first = false;

		os << std::hex << "0x" << std::setw(2) << std::setfill('0') << std::uppercase << +byte;
	}

	os << " ; ";
	for( const auto& byte : element.byte_run)
		os << (byte >= 0x20 && byte <= 0x7E) ? static_cast<char>( byte ) : '.';

	os << "\n";
}

void ASMEmitter::emit_header( std::ostream &os, const IRProgram& ir, std::string name )
{
	os << "; Disasembly of " << name << "\n";
	os << "; Generated by chidisas8\n";
	os << ";\n\n";
	os << "\t.ORG ";

	emit_address( os, ir.origin );

	os << "\n\n";
}


void ASMEmitter::emit( std::ostream& os, const IRProgram& ir, const BinImage& bin_image, OutputMode mode )
{
	emit_header( os, ir, configuration.bin_name );

	for( const auto& element : ir.elements )
        std::visit( [&]( const auto& v ) { emit_element( os, ir, bin_image, mode, v ); }, element );
}
