/*
 * asm_emitter.cc Copyright 2026 Alwin Leerling dna.leerling@gmail.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include "asm_emitter.h"

#include <iomanip>

void ASMEmitter::emit_operand( std::ostream& os, const Operand& op )
{
    std::visit( [&](auto&& v)
	{
        using T = std::decay_t<decltype(v)>;

		auto flags = os.flags();
		auto fill  = os.fill();

		if constexpr( std::is_same_v<T, Reg> )
			os << "V" << std::uppercase << std::hex << +v.index;

		else if constexpr( std::is_same_v<T, Addr> ) {
			std::string target = program->symbols.get_label( v.value );
			if( target.empty() )
				os << "0x" << std::uppercase << std::hex << std::setw(3) << std::setfill('0') << +v.value;
			else
				os << target;
		}

		else if constexpr( std::is_same_v<T, Imm> )
			os << "#" << std::dec << +v.value;

		else if constexpr( std::is_same_v<T, Nibble> )
			os << "0x" << std::uppercase << std::hex << +v.value;

		else if constexpr( std::is_same_v<T, Key> )
			os << "K" << std::uppercase << std::hex << +v.index;

		else if constexpr( std::is_same_v<T, RegCount> )
			os << "V0-V" << std::uppercase << std::hex << +v.count;

		os.fill(fill);
		os.flags(flags);

    }, op);
}

void ASMEmitter::emit_mnemonic( std::ostream& os, const Opcode& opcode )
{
	static std::array<std::string, opcode_count> mnemonics = {
		"NOP", "CLS", "RET", "JP", "CALL", "SE",
		"SNE", "LD", "ADD", "OR", "AND",
		"XOR", "SUB", "SHR", "SUBN", "SHL", "LD I,",
		"JP V0,", "RND", "DRW", "SKP", "SKNP", "LD DT,",
		"LD ST,", "ST K,", "ST DT,", "ADD I,",
		"LD F,", "LD B,", "ST [I],", "LD [I],"
	};

	// os << std::left << std::setw(8) << std::setfill(' ') << mnemonics[ static_cast<int>(opcode) ];
	os << mnemonics[ static_cast<int>(opcode) ];
}

void ASMEmitter::emit_element( std::ostream& os, const InstructionElement& element )
{
	static constexpr int ADDR_WIDTH    = 3;   // 0x200 → 4 chars
	static constexpr int OPCODE_WIDTH  = 4;   // 2 bytes → 4 hex digits
	static constexpr int OPERAND_WIDTH = 12;  // widest operand string

	const Instruction& instruction = element.instruction;

	std::string label = program->symbols.get_label( element.address );

	if( !label.empty() )
		label += ":";

	os << std::left << std::setw(8) << std::setfill(' ') << label;

	if( !configuration.is_clean )
	{
		// os << "0x" << std::setfill( '0' ) << std::setw( 3 ) << std::uppercase << std::hex << element.address << "  ";

		uint16_t opcode_word = ((*program->binary)[ element.address - program->origin ] << 8 ) |
						 		(*program->binary)[ element.address - program->origin + 1 ];


 		os << "0x" << std::hex << std::uppercase
           << std::setw(ADDR_WIDTH)  << std::setfill('0') << element.address << "  "
           << std::setw(OPCODE_WIDTH) << opcode_word << "  ";
    }

	emit_mnemonic( os, instruction.opcode() );
	os << " ";

	bool first = true;

	for( const auto& operand : instruction.operands() ) {
		if( !first )
			os << ", ";
		else
			first = false;

		emit_operand( os, operand );
	}

	os << "\n";
}

void ASMEmitter::emit_element( std::ostream& os, const DataElement& element )
{
	std::string label = program->symbols.get_label( element.address );

	if( !label.empty() )
		label += ":";

	os << std::left << std::setw(8) << std::setfill(' ') << label;

	if( !configuration.is_clean )
		os << "0x" << std::setfill( '0' ) << std::setw( 3 ) << std::uppercase << std::hex << element.address << "  ";

	os << ".DB ";

	bool first = true;

	for( const auto& byte : element.byte_run ) {
		if( !first )
			os << ", ";
		else
			first = false;

		os << std::hex << "0x" << std::setw(2) << std::setfill('0') << std::uppercase << +byte;
	}

	os << " ; ";
	for( const auto& byte : element.byte_run)
		os << (byte >= 0x20 && byte <= 0x7E) ? static_cast<char>( byte ) : '.';

	os << "\n";
}

void ASMEmitter::emit_header( std::ostream &os )
{
	os << "; Disasembly of " << configuration.bin_name << "\n";
	os << "; Generated by chidisas8\n";
	os << ";\n\n";
	os << "\t.ORG 0x" << std::uppercase << std::hex << std::setw(3) << std::setfill('0') << program->origin << "\n\n";
}


void ASMEmitter::emit( std::ostream& os, const IRProgram& ir )
{
	program = &ir;

	emit_header( os );

	for( const auto& element : ir.elements )
        std::visit( [&]( const auto& v ) { emit_element( os, v ); }, element );
}
