/*
 * asm_emitter.cc Copyright 2026 Alwin Leerling dna.leerling@gmail.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include <iomanip>

#include "ir/asm_emitter.h"

void ASMEmitter::emit( std::ostream& os, const IRProgram& ir, const BinImage& bin_image, const SymbolTable& symbols, OutputMode mode )
{
	EmitContext ctx = {
		.os = os,
		.ir = ir,
		.bin_image = bin_image,
		.symbols = symbols,
		.mode = mode
	};

	emit_header( ctx, configuration.bin_name );

	for( const auto& element : ir.elements )
        std::visit( [&]( const auto& v ) { emit_element( ctx, v ); }, element );
}

void ASMEmitter::emit_header( const EmitContext& ctx, std::string name )
{
	ctx.os << "; Disasembly of " << name << "\n";
	ctx.os << "; Generated by chidisas8\n";
	ctx.os << ";\n\n";
	ctx.os << "\t.ORG ";

	emit_address( ctx, ctx.ir.origin );

	ctx.os << "\n\n";
}

void ASMEmitter::emit_element( const EmitContext& ctx, const InstructionElement& element )
{
	const Instruction& instruction = element.instruction;

	if( ctx.mode == OutputMode::Listing ) {
		emit_address( ctx, element.address );
		emit_opcode( ctx, element.address );
	}

	emit_label( ctx, element.address );

	emit_mnemonic( ctx, instruction.opcode() );

	for( bool first = true; const auto& operand : instruction.operands() )
	{
		ctx.os << (first ? " " : ", " );
		first = false;

		emit_operand( ctx, operand );
	}

	ctx.os << "\n";
}

void ASMEmitter::emit_element( const EmitContext& ctx, const DataElement& element )
{
	if( ctx.mode == OutputMode::Listing )
		emit_address( ctx, element.address );

	emit_label( ctx, element.address );

	ctx.os << ".DB";

	for( bool first = true; const auto& byte : element.byte_run )
	{
		ctx.os << (first ? " " : ", " );
		first = false;

		ctx.os << std::hex << "0x" << std::setw(2) << std::setfill('0') << std::uppercase << +byte;
	}

	ctx.os << " ; ";
	for( const auto& byte : element.byte_run)
		ctx.os << (byte >= 0x20 && byte <= 0x7E) ? static_cast<char>( byte ) : '.';

	ctx.os << "\n";
}

void ASMEmitter::emit_address( const EmitContext& ctx, uint16_t address )
{
	ctx.os << "0x" << std::hex << std::uppercase << std::setw(3) << std::setfill('0') << address << "  ";
}

void ASMEmitter::emit_opcode( const EmitContext& ctx, uint16_t address )
{
	uint8_t high_byte = ctx.bin_image[ address - ctx.ir.origin ];
	uint8_t low_byte  = ctx.bin_image[ address - ctx.ir.origin + 1 ];

	ctx.os << std::hex << std::uppercase
		<< std::setw(2) << std::setfill('0') << +high_byte << " ";

	ctx.os << std::hex << std::uppercase
		<< std::setw(2) << std::setfill('0') << +low_byte << "  ";
}

void ASMEmitter::emit_label( const EmitContext& ctx, uint16_t address )
{
	std::string label = ctx.symbols.get_label( address );

	if( !label.empty() )
		label += ":";

	ctx.os << std::left << std::setw(8) << std::setfill(' ') << label;
}

void ASMEmitter::emit_mnemonic( const EmitContext& ctx, const Opcode& opcode )
{
	static std::array<std::string, opcode_count> mnemonics = {
		"NOP", "CLS", "RET", "JP", "CALL", "SE",
		"SNE", "LD", "ADD", "OR", "AND",
		"XOR", "SUB", "SHR", "SUBN", "SHL", "LD I,",
		"JP V0,", "RND", "DRW", "SKP", "SKNP", "LD DT,",
		"LD ST,", "ST K,", "ST DT,", "ADD I,",
		"LD F,", "LD B,", "ST [I],", "LD [I],"
	};

	ctx.os << mnemonics[ static_cast<int>(opcode) ];
}

struct StreamStateGuard
{
    StreamStateGuard(std::ostream& os) : os(os), flags(os.flags()), fill(os.fill()) {}

    ~StreamStateGuard() {
        os.flags(flags);
        os.fill(fill);
    }

    std::ostream& os;
    std::ios::fmtflags flags;
    char fill;
};

void ASMEmitter::emit_operand( const EmitContext& ctx, const Operand& op )
{
    std::visit( [&](auto&& v)
	{
		StreamStateGuard guard(ctx.os);

        using T = std::decay_t<decltype(v)>;

		if constexpr( std::is_same_v<T, Reg> )
			ctx.os << "V" << std::uppercase << std::hex << +v.index;

		else if constexpr( std::is_same_v<T, Addr> ) {
			std::string target = ctx.symbols.get_label( v.value );
			if( target.empty() )
				ctx.os << "0x" << std::uppercase << std::hex << std::setw(3) << std::setfill('0') << +v.value;
			else
				ctx.os << target;
		}

		else if constexpr( std::is_same_v<T, Imm> )
			ctx.os << "#" << std::dec << +v.value;

		else if constexpr( std::is_same_v<T, Nibble> )
			ctx.os << "0x" << std::uppercase << std::hex << +v.value;

		else if constexpr( std::is_same_v<T, Key> )
			ctx.os << "K" << std::uppercase << std::hex << +v.index;

		else if constexpr( std::is_same_v<T, RegCount> )
			ctx.os << "V0-V" << std::uppercase << std::hex << +v.count;

    }, op);
}
