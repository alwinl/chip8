/*
 * Copyright 2021 Alwin Leerling <dna.leerling@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 *
 */

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <unordered_map>
#include <functional>

#include "disassembler.h"
#include "decoder.h"
#include "utils.h"

void print_databytes( std::ostream &os, DataBytes& data_bytes, bool is_clean )
{
	if( !is_clean )
		os << format_address(data_bytes.address) << "\t\t";

	os << ".DB\t";

	for( uint8_t byte : data_bytes.byte_run )
		os << format_byte( byte ) << " ";

	os << " ; ";
	for(auto b : data_bytes.byte_run) {
		if(b >= 0x20 && b <= 0x7E)
			os << static_cast<char>(b);
		else
			os << '.';
	}

	os << '\n';
};

void print_instruction( std::ostream &os, Instruction& inst, std::string label, bool is_clean )
{
	if( is_clean ) {
		os << inst.mnemonic << " " << inst.argument << label << "\n";

	} else {
		uint8_t low_byte = inst.opcode & 0xFF;
		uint8_t high_byte = (inst.opcode >> 8) & 0xFF;

		os << format_address(inst.address) << "\t\t" << format_naked_byte( high_byte ) << " " << format_naked_byte( low_byte ) << "\t"
			<< inst.mnemonic << " " << inst.argument << label << "\n";
	}
};

void Disassembler::read_input( std::istream& is )
{
	uint16_t address = origin;
    int byte;

    while( (byte = is.get()) != EOF )
		memory.add_byte( address++, static_cast<uint8_t>(byte) );
}

void Disassembler::disassemble()
{
	std::stack<uint16_t> address_stack;
	Decoder decoder;

	address_stack.push( origin );	// Push the start address

	while( !address_stack.empty() ) {

		uint16_t address = address_stack.top();
		address_stack.pop();

		if( !decoded_instructions.insert(address).second )
			continue; // already decoded

		auto result = decoder.decode( address, memory );

		memory.mark_instruction( address );
		instructions.push_back( result.instruction );

		for( auto address : result.next_addresses )
			address_stack.push( address );

		targets.add( result.target );
	}

	std::sort(instructions.begin(), instructions.end(),
			[](const Instruction& a, const Instruction& b) {
				return a.address < b.address;
			});

	targets.sort_vectors();

	collect_data_bytes( );

	std::sort(databytes.begin(), databytes.end(),
			[](const DataBytes& a, const DataBytes& b) {
				return a.address < b.address;
			});
}

void Disassembler::print_output( std::ostream &os, bool is_clean )
{
	auto output_label = [this]( std::ostream &os, unsigned int address )
	{
		std::string label = targets.get_label( address );
		if( !label.empty() )
			os << label << ":\n";

		os << "\t\t";
	};

	// configure the stream
	os << std::setfill( '0' );
	os << std::setw( 3 );
	os << std::hex << std::uppercase;

	// write the header
	os << "; Disasembly of " << bin_name << "\n";
	os << "; Generated by chidisas8\n";
	os << ";\n\n";
	os << "\t.ORG " << format_address( origin ) << "\n\n";

	std::vector<Instruction>::iterator instruction_iter = instructions.begin();
	std::vector<DataBytes>::iterator datarun_iter = databytes.begin();

	while( instruction_iter != instructions.end() && datarun_iter != databytes.end() ) {

		if( ( *instruction_iter ).address < ( *datarun_iter ).address ) {
			output_label( os, (*instruction_iter).address );
			std::string label = targets.get_label( instruction_iter->target_address );
			print_instruction( os, *instruction_iter, label, is_clean );
			++instruction_iter;
		} else {
			output_label( os, (*datarun_iter).address );
			print_databytes( os, *datarun_iter, is_clean );
			++datarun_iter;
		}
	}

	// what have we remaining
	while( instruction_iter != instructions.end() ) {
		output_label( os, (*instruction_iter).address );
		std::string label = targets.get_label( instruction_iter->target_address );
		print_instruction( os, *instruction_iter, label, is_clean );
		++instruction_iter;
	}

	while( datarun_iter != databytes.end() ) {
		output_label( os, (*datarun_iter).address );
		print_databytes( os, *datarun_iter, is_clean );
		++datarun_iter;
	}
}

void Disassembler::collect_data_bytes()
{
    std::vector<uint8_t> datarun;
    uint16_t run_start = 0;

    const uint16_t start = memory.mem_start();
    const uint16_t end   = memory.mem_end();

	// The raw bytes that have not been marked as instruction bytes are thus data bytes
	// Chuck them together into DataBytes objects

    for( uint16_t addr = start; addr < end; ++addr ) {

        // If byte is NOT part of an instruction → it's data
        if( !memory.is_instruction(addr) ) {

            // If this byte is a jump target → end previous run
            if( !datarun.empty() && ! targets.get_label( addr ).empty()) {

                databytes.push_back( DataBytes(run_start, datarun) );
                datarun.clear();
            }

            if( datarun.empty() )
                run_start = addr;

            datarun.push_back( memory.get_byte(addr) );

        } else {

            // Instruction byte interrupts data run
            if( !datarun.empty() ) {

                databytes.push_back( DataBytes(run_start, datarun) );
                datarun.clear();
            }
        }
    }

    // Flush leftover at end of memory block
    if( !datarun.empty() )
        databytes.push_back( DataBytes(run_start, datarun) );
}
