/*
 * Copyright 2021 Alwin Leerling <dna.leerling@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include "disassembler.h"

#include <algorithm>
#include <sstream>
#include <stack>
#include <unordered_set>
#include <fstream>
#include <iostream>

#include "cmdlineparser.h"
#include "decoder.h"
#include "utils.h"

void Disassembler::configure( const CmdLineParser &cmd )
{
	configuration = cmd;

	memory.set_origin( cmd.get_origin() );
}

void Disassembler::read_input( )
{
	if( configuration.get_source_name() != "-" ) {

		std::ifstream source_file = std::ifstream( configuration.get_source_name(), std::ios::in | std::ios::binary );
		if( !source_file.is_open() )
			throw std::runtime_error("Cannot open source file: " + configuration.get_source_name());

		read_input( source_file );

	} else
		read_input( std::cin );
}

void Disassembler::read_input( std::istream& is )
{
	uint16_t address = configuration.get_origin();
    char byte;

    while( is.get( byte ) )
		memory.add_byte( address++, byte );

	if( !is.eof() )
        throw std::runtime_error("Error reading from input stream.");
}

void Disassembler::disassemble()
{
	collect_instructions();

	collect_data_bytes( );

    std::sort(elements.begin(), elements.end(),
        [](const ASMElement& a, const ASMElement& b) {
            return a.address < b.address;
        });
}

void Disassembler::collect_instructions()
{
	std::stack<uint16_t> address_stack;
	std::unordered_set<uint16_t> decoded_instructions;
	Decoder decoder;

	address_stack.push( configuration.get_origin() );	// Push the start address

	while( !address_stack.empty() ) {

		while( !address_stack.empty() ) {

			uint16_t address = address_stack.top();
			address_stack.pop();

			if( !decoded_instructions.insert(address).second )
				continue; // already decoded

			auto result = decoder.decode( address, memory );

			memory.mark_instruction( address );

			elements.push_back( ASMElement { address, result.instruction } );

			for( auto next_address : result.next_addresses )
				address_stack.push( next_address );

			targets.add( result.target );
		}

		targets.sort_vectors();

		for( auto table_address : targets.get_index_list() ) {

			while( memory.contains(table_address) && targets.get_label(table_address).empty() ) {

				address_stack.push( table_address );
				table_address += 2;
			}
		}
	}
}

void Disassembler::collect_data_bytes()
{
    std::vector<uint8_t> datarun;
    uint16_t run_start = 0;

    const uint16_t start = memory.mem_start();
    const uint16_t end   = memory.mem_end();

	auto flush = [&]()
	{
		if( !datarun.empty() ) {
			elements.push_back( ASMElement { run_start, DataBytes{ run_start, datarun } } );
			datarun.clear();
		}
	};

	// The raw bytes that have not been marked as instruction bytes are thus data bytes
	// Chunk them together into DataBytes objects

    for( uint16_t addr = start; addr < end; ++addr ) {

        if( !memory.is_instruction(addr) ) {		// If byte is NOT part of an instruction → it's data

            // If this byte is a jump target → end previous run
            if( ! targets.get_label( addr ).empty() )
				flush();

            if( datarun.empty() )
                run_start = addr;

            datarun.push_back( memory.get_byte(addr) );

        } else            // Instruction byte interrupts data run
			flush();
    }

	flush();
}

void emit_header(std::ostream &os, std::string bin_name, uint16_t origin )
{
	os << "; Disasembly of " << bin_name << "\n";
	os << "; Generated by chidisas8\n";
	os << ";\n\n";
	os << "\t.ORG " << format_address( origin ) << "\n\n";
}

void emit_label( std::ostream &os, std::string label )
{
	if( !label.empty() )
		os << label << ":\n";

	os << "\t\t";
};

void emit_databytes( std::ostream &os, const DataBytes& data_bytes, bool is_clean )
{
	if( !is_clean )
		os << format_address(data_bytes.address) << "  ";

	os << ".DB  ";

	for( uint8_t byte : data_bytes.byte_run )
		os << format_byte( byte ) << " ";

	os << " ; ";
	for(auto b : data_bytes.byte_run) {
		if(b >= 0x20 && b <= 0x7E)
			os << static_cast<char>(b);
		else
			os << '.';
	}

	os << '\n';
};

void emit_instruction( std::ostream &os, const Instruction& inst, std::string label, bool is_clean )
{
	if( !is_clean ) {
		os << format_address(inst.address) << "  ";

		uint8_t low_byte = inst.opcode & 0xFF;
		uint8_t high_byte = (inst.opcode >> 8) & 0xFF;

		os << format_naked_byte( high_byte ) << " " << format_naked_byte( low_byte ) << "   ";
	}

	os << format_mnemonic(inst.mnemonic) << " " << inst.argument << label << "\n";
};

void Disassembler::print_output( std::ostream& os )
{
	emit_header( os, configuration.get_program_name(), configuration.get_origin() );

	for( const auto& elem : elements ) {

		emit_label( os, targets.get_label( elem.address ) );

		std::visit( [&]( auto&& value )
		{
			using T = std::decay_t<decltype(value)>;

			if constexpr ( std::is_same_v<T, Instruction> )
				emit_instruction( os, value, targets.get_label( value.target_address ), configuration.is_clean() );
			else
				emit_databytes( os, value, configuration.is_clean() );

		}, elem.value );
	}
}

void Disassembler::print_output( )
{
	if( configuration.get_output_name() != "-" ) {

		std::ofstream out_file = std::ofstream( configuration.get_output_name(), std::ios::out );
		if( !out_file.is_open() )
			throw std::runtime_error("Cannot open output file: " + configuration.get_output_name() );

		print_output( out_file );

	} else
		print_output( std::cout );
}
